#! /bin/sh
#
#-	Stty - stty with form interface
#-
#-	This program  allows user to view  all the terminal parameters
#-	and change them by form.  Help messages has been added to each
#-	field to make change parameter easier.
#
#	Author:		Paul Lew, General Systems Group, Salem, NH
#	Created at:	01/09/88  07:40 PM
#	Last update:	01/12/88  10:34 PM  (Edition: 79)
#
#---------------------------------------------------------------#
#     Get current tty setting and store as shell variables	#
#---------------------------------------------------------------#
sttyfile="/tmp/stty$$"
tmpfile="/tmp/sttytmp$$"
trap "trap '' 0 1 2 3 15;					\
      /bin/rm -f $sttyfile $tmpfile;				\
      exit" 0 1 2 3 15
stty everything 2> $sttyfile
tr -d ':()' < $sttyfile | awk \
'BEGIN	{ q= 39; fmt = sprintf "%%s=%c%%s%c\n", q, q; }		\
	NR == 1	{						\
		printf fmt, "tt_tty",    $1;			\
		printf fmt, "tt_speed",  $4;			\
		printf fmt, "tt_row",    $6;			\
		printf fmt, "tt_column", $8;			\
		}						\
	2 <= NR && NR <= 5 {					\
		for (i=1; i<=NF; i++) {				\
			if (substr($(i),1,1)=="-") {		\
				yon = "No";			\
				name = substr($(i),2,99);	\
				}				\
			else	{				\
				yon = "Yes";			\
				name = $(i);			\
				}				\
			print "tt_" name "=" yon;		\
			}					\
		}						\
	NR == 7 {						\
		printf fmt, "tt_erase",  $1;			\
		printf fmt, "tt_kill",   $2;			\
		printf fmt, "tt_werase", $3;			\
		printf fmt, "tt_rprnt",  $4;			\
		printf fmt, "tt_flush",  $5;			\
		printf fmt, "tt_lnext",  $6;			\
		n = split ($7, part, "/");			\
		printf fmt, "tt_susp",   part[1];		\
		printf fmt, "tt_suspo",  part[2];		\
		printf fmt, "tt_intr",   $8;			\
		printf fmt, "tt_quit",   $9;			\
		n = split ($10, part, "/");			\
		printf fmt, "tt_stop",   part[1];		\
		printf fmt, "tt_start",  part[2];		\
		printf fmt, "tt_eof",    $11;			\
		}' > $tmpfile
#---------------------------------------------------------------#
#	     Prepare variable for sf to display			#
#---------------------------------------------------------------#
. $tmpfile
/bin/rm -f $tmpfile
if [ $tt_raw = "Yes" ]; then tt_mode="raw"
elif [ $tt_cbreak = "Yes" ]; then tt_mode="cbreak"
else tt_mode="cooked"
fi
if [ $tt_nl = "Yes" ]; then tt_nl="No"; else tt_nl="Yes"; fi
if [ $tt_litout = "Yes" ]; then tt_litout="No"; else tt_litout="Yes"; fi
if [ $tt_nohang = "Yes" ]; then tt_nohang="No"; else tt_nohang="Yes"; fi
#---------------------------------------------------------------#
#	   Invoke sf to allow user make changes			#
#---------------------------------------------------------------#
s=s=/Yes/No
sf -o $tmpfile -bmu << sf_eof
	  ***** Terminal Setting for BSD 4.3 System *****

tty discipline: ~~~~	speed: ~~~~~	Rows: ~~~	Columns: ~~~

Accept even parity input: ~~~   Mode: ~~~~~~      Treat CR as NL: ~~~
Accept odd  parity input: ~~~   Input Echo: ~~~   Map upper to lower: ~~~
Flow control enable: ~~~        Print Tabs: ~~~

New TTY Discipline Specific:
    Echo BS on erase char: ~~~    Wipe out erased char: ~~~   
    Echo CTRL char as ^x: ~~~     Wipe out erased line: ~~~
    Background job stop if output: ~~~   Convert tilde: ~~~  Flush output: ~~~
    Start/Stop output on carrier transition: ~~~    Output processing: ~~~
    Pass 8th bit: ~~~   Hang up if carrier drop: ~~~
    Input Pending: ~~~  only XON resume output: ~~~

Terminal characters:
    char erase: ~~    reprint current line: ~~   literal next char: ~~
    word erase: ~~    flush output: ~~
    line erase: ~~    end of file: ~~
    interrupt:  ~~    suspend current job: ~~    stop host output (XOFF): ~~
    quit:       ~~    suspend with output: ~~    start host output (XON): ~~

.v=tt_discipline.d=new.s=/new/net/old.
.h=Berkeley new tty driver.
.h=net discipline, for communication purpose.
.h=old tty driver from V7 Unix.

.v=tt_speed.d=$tt_speed.
.s=/0/50/75/110/134/150/200/300/600/1200/1800/2400/4800/9600/exta/extb.
.h=hang up phone line immdeidately.
.h=50.h=75.h=110.h=134.h=150.h=200.h=300.h=600.h=1200.h=1800.h=2400.h=4800.
.h=9600.h=exta (19200 on DH-11 board).h=extb (not implemented yet).

.v=tt_row.d=$tt_row.v=tt_column.d=$tt_column.

.v=tt_even.d=$tt_even.$s.
.h=Strip parity bit for even parity input char.
.h=Throw away even parity input char.

.v=tt_mode.d=$tt_mode.s=/cooked/cbreak/raw.
.h=Cooked mode - with input editing, end by newline.
.h=Cbreak mode - return char as it typed except interrupt, flow control.
.h=Raw mode - return every char as it typed.

.v=tt_nl.d=$tt_nl.$s.
.h=Allow CR for NL, and output CR-LF for CR or NL.
.h=Accept only newline to end lines.

.v=tt_odd.d=$tt_odd.$s.
.h=Strip parity bit for odd parity input char.
.h=Throw away odd parity input char.

.v=tt_echo.d=$tt_echo.$s.
.h=Echo back every character typed.
.h=Do not echo characters, good for Emacs inferior shell.

.v=tt_lcase.d=$tt_lcase.$s.
.h=This is for terminal that do not have lowercase letter.
.h=This is for modern day terminal.

.v=tt_tandem.d=$tt_tandem.$s.
.h=system sends out stop/start char when queue is near overflow/empty.
.h=Application program have to handle XON/OFF.

.v=tt_tabs.d=$tt_tabs.$s.
.h=Preserve tabs when printing.
.h=Replace tabs by spaces when printing (for terminal with no hardware tabs).

.v=tt_crtbs.d=$tt_crtbs.$s.
.h=Echo backspaces on erase characters, useful for CRT.
.h=do not echo backspaces on erase characters, useful for hardcopy terminals.

.v=tt_crterase.d=$tt_crterase.$s.
.h=Wipe out erased characters with backspace-space-backspace.
.h=Echo erased characters backwards within \\ and /.

.v=tt_ctlecho.d=$tt_ctlecho.$s.
.h=Delete will be ^?, print two BS following the EOT char (CTRL D).
.h=CTRL char echo as themselves; in cooked mode EOT (CTRL-D) is not echoed.

.v=tt_crtkill.d=$tt_crtkill.$s.
.h=Wipe out input on like kill ala crterase.
.h=Just echo line kill character and a newline on line kill.

.v=tt_tostop.d=$tt_tostop.$s.
.h=Background jobs stop if they attempt terminal output.
.h=Output from background jobs to the terminal is allowed.

.v=tt_tilde.d=$tt_tilde.$s.
.h=Convert ~ to \` on output (for Hazeltine terminals).
.h=Leave poor ~ char alone.

.v=tt_flusho.d=$tt_flusho.$s.
.h=Output is being discarded usually because user hit CTRL O.
.h=Output is not being discarded.

.v=tt_mdmbuf.d=$tt_mdmbuf.$s.
.h=Start/stop output on carrier transitions.
.h=Return error if write attempted after carrier drops.

.v=tt_litout.d=$tt_litout.$s.
.h=Do normal output processing, inserting delays, etc.
.h=Send output characters without any processing.

.v=tt_pass8.d=$tt_pass8.$s.
.h=pass 8th bit.
.h=strip off 8th bit.

.v=tt_nohang.d=$tt_nohang.$s.
.h=Send hangup signal to control process group when carrier drops.
.h=Do not send hangup signal if carrier drops.

.v=tt_pendin.d=$tt_pendin.$s.
.h=Input is pending after a switch from cbreak to cooked.
.h=Input is not pending.

.v=tt_decctlq.d=$tt_decctlq.$s.
.h=This is compatible with DEC vendor supplied systems.
.h=After output is suspended, any char will restart it.

.v=tt_erase.d=$tt_erase.v=tt_rprnt.d=$tt_rprnt.v=tt_lnext.d=$tt_lnext.
.v=tt_werase.d=$tt_werase.v=tt_flush.d=$tt_flush.
.v=tt_kill.d=$tt_kill.v=tt_eof.d=$tt_eof.
.v=tt_intr.d=$tt_intr.v=tt_susp.d=$tt_susp.v=tt_stop.d=$tt_stop.
.v=tt_quit.d=$tt_quit.v=tt_suspo.d=$tt_suspo.v=tt_start.d=$tt_start.
sf_eof
#---------------------------------------------------------------#
#		  Process variable returned			#
#---------------------------------------------------------------#
. $tmpfile
/bin/rm -f $tmpfile $sttyfile
tt_even=`[ $tt_even = "Yes" ] || echo -`even
case $tt_mode in
	cooked)	tt_raw='-raw'; tt_cbreak='-cbreak';;
	cbreak)	tt_raw='-raw'; tt_cbreak='cbreak';;
	raw)	tt_raw='raw';  tt_cbreak='-cbreak';;
	esac
tt_nl=`[ $tt_nl = "No" ] || echo -`nl
tt_odd=`[ $tt_odd = "Yes" ] || echo -`odd
tt_echo=`[ $tt_echo = "Yes" ] || echo -`echo
tt_lcase=`[ $tt_lcase = "Yes" ] || echo -`lcase
tt_tandem=`[ $tt_tandem = "Yes" ] || echo -`tandem
tt_tabs=`[ $tt_tabs = "Yes" ] || echo -`tabs
tt_crtbs=`[ $tt_crtbs = "Yes" ] || echo -`crtbs
tt_crterase=`[ $tt_crterase = "Yes" ] || echo -`crterase
tt_ctlecho=`[ $tt_ctlecho = "Yes" ] || echo -`ctlecho
tt_crtkill=`[ $tt_crtkill = "Yes" ] || echo -`crtkill
tt_tostop=`[ $tt_tostop = "Yes" ] || echo -`tostop
tt_tilde=`[ $tt_tilde = "Yes" ] || echo -`tilde
tt_flusho=`[ $tt_flusho = "Yes" ] || echo -`flusho
tt_mdmbuf=`[ $tt_mdmbuf = "Yes" ] || echo -`mdmbuf
tt_litout=`[ $tt_litout = "No" ] || echo -`litout
tt_pass8=`[ $tt_pass8 = "Yes" ] || echo -`pass8
tt_nohang=`[ $tt_nohang = "No" ] || echo -`nohang
tt_pendin=`[ $tt_pendin = "Yes" ] || echo -`pendin
tt_decctlq=`[ $tt_decctlq = "Yes" ] || echo -`decctlq
tt_noflsh=`[ $tt_noflsh = "Yes" ] || echo -`noflsh
#---------------------------------------------------------------#
#	Output stty command to file (or stdout if no arg)	#
#---------------------------------------------------------------#
if [ "$1" = "" ]; then
	sttyfile=/dev/tty
else
	sttyfile="$1"
	fi
cat > $sttyfile << cat_eof
set noglob
stty $tt_discipline  speed $tt_speed				\\
    $tt_even $tt_odd $tt_raw $tt_nl $tt_echo $tt_lcase		\\
    $tt_tandem	$tt_tabs $tt_cbreak				\\
    $tt_crtbs $tt_crterase $tt_crtkill $tt_ctlecho $tt_tostop	\\
    $tt_tilde $tt_flusho $tt_mdmbuf $tt_litout $tt_pass8	\\
    $tt_nohang $tt_pendin $tt_decctlq $tt_noflsh		\\
    erase "$tt_erase"  rprnt "$tt_rprnt"  lnext "$tt_lnext"	\\
    werase "$tt_werase"  flush "$tt_flush"			\\
    kill "$tt_kill"  eof "$tt_eof"				\\
    intr "$tt_intr"  susp "$tt_suspd"  stop "$tt_stop"		\\
    quit "$tt_quit"  susp "$tt_suspd"  start "$tt_start"
unset noglob
cat_eof
#
# 1) new tty, speed 1200 baud, 24 rows, 80 columns
# 2) even odd -raw -nl echo -lcase -tandem tabs -cbreak 
# 3) crt: (crtbs crterase crtkill ctlecho) -tostop 
# 4) -tilde -flusho -mdmbuf -litout -pass8 -nohang 
# 5) -pendin decctlq -noflsh 
# 6) erase  kill   werase rprnt  flush  lnext  susp   intr   quit   stop   eof
# 7)  ^?    ^U     ^W     ^R     ^O     ^V     ^Z/^Y  ^C     ^\     ^S/^Q  ^D
#      1     2      3      4      5      6      7      8      9      10    11
