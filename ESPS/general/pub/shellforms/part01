#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	sf.1 README MANIFEST COPYRIGHT TODO Print Stty Lib basic.h
#	form.h field.h term.h Makefile
export PATH; PATH=/bin:$PATH
echo shar: extracting "'sf.1'" '(6409 characters)'
if test -f 'sf.1'
then
	echo shar: will not over-write existing file "'sf.1'"
else
sed 's/^X//' << \SHAR_EOF > 'sf.1'
X.TH sf 1-gsg "Ver 1.8  01/28/88"
X.SH NAME
Xsf - shell form (form editor to be used in shell scripts)
X.SH SYNOPSIS
X.B sf
X[-Hbhmpru] [-o outfile] [formfile]
X.IP -H
Xdisplay help message
X.IP -b
Xgenerate Bourne shell script, default is Csh script
X.IP -h
Xdisplay input field in highlight mode
X.IP -m
Xdisplay help message automatically for selection fields
X.IP -o
Xset output file to outfile (if not given, no output)
X.IP -p
Xgenerate perl script, default is Csh script
X.IP -r
Xdisplay input field in reverse video mode
X.IP -u
Xdisplay input field in underline mode
X.IP formfile
Xfile contains form layout (default to stdin)
X.SH DESCRIPTION
X.I Sf
Xis a tool that allows users write shell scripts with elegant form
Xediting user interface.  It reads an input form, displays it on the
Xscreen, and process all the data entry.  At the end of the form
Xfilling session, sf generates a file contains Csh set commands (or
XBourne shell commands if -b is specified, Perl script if -p is
Xspecified) which is intended to be 'sourced' by Csh (or "." if you use
XBourne shell, "eval" in perl).  After source operation, all the fields
Xin the form will be defined as shell variables and shell script can
Xcontinue after that.
X.PP
XThe form template may be stored in a file, but the easiest way to use
Xsf is to send it thru stdin so you do not have to have a script file
Xand a separate form file to do one job.
X.SH FORM DEFINITION
XInput field are specified by '~' characters in the form template,
Xtherefore, it it not possible to have ~ characters displayed on the
Xform.  If the 1st char of a line is a CTRL L (^L) character, it
Xindicates the end of form layout part and the start of field
Xdefinition part.  In field definition part, the 1st character on a
Xline will be used as the delimiter of each token on that line.
XCurrently only five tokens are valid:
X.IP "v="
Xthis means the following token string (until the next delimiter or
Xeol) will be used as the symbol to set at shell.
X.IP "d="
Xthis means the following token should be used as the default value to
Xstore in the form before form is displayed.
X.IP "s="
Xthis means the following string is the selection list with the first
Xcharacter as the delimiter, the ending delimiter is optional.
X.IP "h="
Xthis means the possible help message for selection field, multiple h=
Xis needed. For example, if you have a selection field:
X.IP
Xs=/find/add/delete/print/quit
X.IP
Xyou should specify the help message by:
X.sp
X.nf
X	h=find record based on user name
X	h=add a new record to database
X	h=delete current user from database
X	h=print current user record on printer
X	h=quit this program
X.fi
X.IP
Xwhere each h= entry refers to each of the fields in selection list.
X.IP "a="
Xthis specifies the possible attributes for the given field which
Xshould be supplied as parameters, the following characters will be
Xrecognized:
X.RS
X.IP "a"
Xautotab, when user typed a character at the last position, the field
Xediting will be terminated and cursor will move to next field on the
Xform.
X.IP "d"
Xdigits only field, any characters not '0' - '9' will not be accepted.
X.IP "b"
Xblock field, next/prev block command (ESC N, ESC P) will move cursor
Xto next field with block attribute set. This makes it easier for user
Xto move to the desired 'block' of fields. (not implemented yet)
X.RE
X.SH COMMANDS
XField editing commands are designed to be simple.  Sf understands
Xarrow keys so it can be used easily for non-technical personnel.
XField cursor movement keys are Emacs-like with one major difference:
Xthere is no insert mode (any volunteer?), character entered will
Xoverwrite existing data.  The following is a list of them:
X.IP "TAB"
XMove to next field on the screen. If there are more fields on the current
Xline, move to the first one to the right of current field.  If there is
Xno more fields, moves to the first field on the following lines.
X.IP "CTRL T"
XSame as TAB except moves backwards.
X.IP "RETURN or LINEFEED"
XTerminates the form edit session.
X.IP "up arrow or CTRL P"
XMoves to the closest fields on the previous lines, wrap around if no more.
X.IP "down arrow or CTRL N"
XSame as up arrow execpt moves downward instead.
X.IP "left arrow or CTRL B"
XMoves cursor left on character on the current field.
X.IP "right arrow or CTRL F"
XMoves cursor right on character on the current field.
X.IP "CTRL E"
XMoves cursor to the end of last non-blank characters on the current field.
X.IP "CTRL A"
XMoves cursor to the beginning of the current field.
X.IP "CTRL U"
XBlanks all the characters from cursor to beginning of the current field.
X.IP "CTRL K"
XBlanks all the characters from cursor to the end of the current field.
X.IP "CTRL W"
XBlanks the previous word before cusor on the current field.
X.IP "CTRL L"
XRedisplay the form.
X.IP "CTRL Z"
X(Or whatever your stop key is) Stop sf.
X.IP "CTRL C"
X(Or whatever your interrupt key is) Aborts the form editing session,
Xsf will display a message and terminate.
X.SH EXAMPLE
XThe following is an example of how to use it (C shell script):
X.PP
X.nf
X#! /bin/csh -f
Xset srcfile = "/tmp/form.$$"
Xsf -o ${srcfile} -u << sf_eof
X
X	     General Systems Group Fast Printer Spooler
X
X   File Name: ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X
X	[-#] Number of copies:	~~~	      [-h] Burst Header Page: ~~~
X	[-m] Send mail on completion: ~~~     [-p] Format with pr:    ~~~
X
X	[-J] Job Name:		~~~~~~~~~~~~~
X	[-C] Class Name:	~~~~~~~~~~~~~
X	[-T] Title for pr:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X
X		    Current Print Queue Status
X`lpq | head -5`
X
X	[Press TAB to move to next field, RETURN to execute]
X
X@v=fn@d=$*@
X@v=copy@d=1@a=d@v=burst@s=/Yes/No@
X@v=mail@s=/No/Yes@v=pr@s=/Yes/No@
X@v=job@d=$1@
X@v=class@d=`hostname`@
X@v=title@d=$1@
Xsf_eof
Xif ( ! -e ${srcfile} ) goto end
Xsource ${srcfile}
Xset copy burst pr mail tf cf jf
Xif ( "${copy}" != "1" ) set copy = "-#${copy}"
Xif ( "${burst}" != "Yes" ) set burst = "-h"
Xif ( "${pr}" == "Yes" ) set pr = "-p"
Xif ( "${mail}" == "Yes" ) set mail = "-m"
Xif ( "${title}" != "" ) set tf = "-T"
Xif ( "${class}" != "" ) set cf = "-C"
Xif ( "${job}" != "" ) set jf = "-J"
Xif ( "${fn}" != "" ) then
X	lpr ${copy} ${burst} ${pr} ${mail} ${tf} "${title}" \
X	${cf} "${class}" ${jf} "${job}" ${fn}
X	endif
X/bin/rm -f ${srcfile}
Xend:
X.nf
X.fi
X.SH AUTHOR
XPaul Lew
X.br
XGeneral Systems Group, Salem NH
X.SH BUGS
XThis version of sf comes from my previous work on IBM-PC for my friends and
Xit is rather primitive.  Form editor itself may be improved comments are
Xwelcome.
SHAR_EOF
if test 6409 -ne "`wc -c < 'sf.1'`"
then
	echo shar: error transmitting "'sf.1'" '(should have been 6409 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'README'" '(1618 characters)'
if test -f 'README'
then
	echo shar: will not over-write existing file "'README'"
else
sed 's/^X//' << \SHAR_EOF > 'README'
XThis is sf (shell form) version 1.8.  Having used so many high quality
Xprograms from the net, this is my time to contribute.
X
XThis  program  was written to   augment the versatility  of  Unix user
Xinterface in shell level.   It does  only  one  thing -- form editing.
XShell script writer has to process the data afterwards.
X
XSome typical usage for this program are:
X
X    o interface for non-Unix user  to access system  resource. One can
X      easily write shell  scripts  display menus and forms  for novice
X      users.
X
X    o Something like bulletin board system might use sf interface.
X
X    o I personally  use   it   to interface  with those commands  with
X      zillions of  options  (e.g.,  stty, sa, admin,  cpio)  or  those
X      commands used infrequently   (e.g., print).  I  used capitalized
X      command  names for those  shell scripts with sf interface, e.g.,
X      Stty for stty, Admin for admin, etc.
X
X    o With  proper database  interface  program,  sf  may be  used for
X      system administrator to configure system, e.g.,  add new user to
X      system, configure I/O ports,  etc.   The recently posted  "perl"
X      might be a good candidate.
X
XTo build sf, simply type: "make".  Sf  has not been  tested on non-BSD
Xsystem,  some porting will  be   needed.  You might   want to run some
Xsample scripts supplied with the package to see how it works.  Enjoy!
X
XSample scripts:
X
X	Print	(csh)	interface to BSD 4.2 print command
X	Stty	(sh)	interface to BSD 4.3 stty command
X	Lib	(csh)	maintain on-line library index (need modification)
X
XMail bugs/comments to Paul Lew at {olivea,harvard,decvax}!gsg!lew
SHAR_EOF
if test 1618 -ne "`wc -c < 'README'`"
then
	echo shar: error transmitting "'README'" '(should have been 1618 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'MANIFEST'" '(1002 characters)'
if test -f 'MANIFEST'
then
	echo shar: will not over-write existing file "'MANIFEST'"
else
sed 's/^X//' << \SHAR_EOF > 'MANIFEST'
X----shar.01-----
X 35fe 31508    185   1131   6409 sf.1
X 8d87  7256     37    245   1618 README
X ab4a   988      1      1     17 MANIFEST
X f02a 23081      6     48    284 COPYRIGHT
X e960 10353     24    145    894 TODO
X 6608 50247     95    334   2591 Print
X 927c  8727    266   1316  10025 Stty
X 9fe4 53398    282   1157   8749 Lib
X e24c 59953     52    121    829 basic.h
X 89f3 38278     36    257   1383 form.h
X b07c 51385     17    113    665 field.h
X cece 19140     21     63    285 term.h
X 867f 47573    121    477   3543 Makefile
X----shar.02-----
X 2f99 30654    124    581   4115 sf.c
X fd6c 10497    225    813   5898 form.c
X 0269   995    349   1238   8779 load.c
X 50ad 52985    259   1001   6631 field.c
X ddfa  7101    219    818   5773 selection.c
X 8c69 16251     49    168   1253 keyword.c
X e398 32766     50    171   1317 option.c
X 9695 13569    109    380   2999 msg.c
X 1a39 56277    242   1037   6575 term.c
X 5b38  5787    177    486   4106 io.c
X aa6e  1634     56    277   1880 summary.c
SHAR_EOF
if test 1002 -ne "`wc -c < 'MANIFEST'`"
then
	echo shar: error transmitting "'MANIFEST'" '(should have been 1002 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'COPYRIGHT'" '(284 characters)'
if test -f 'COPYRIGHT'
then
	echo shar: will not over-write existing file "'COPYRIGHT'"
else
sed 's/^X//' << \SHAR_EOF > 'COPYRIGHT'
Xsf Version 1.8, Copyright (c) 1988, Paul Lew
X
X    You may copy this program (sf) in whole or in  part as long as you
X    don't try to make  money off it,   or pretend that  you  wrote it.
X    This   COPYRIGHT notice   should  always   be  included with   all
X    distributions of sf.
SHAR_EOF
if test 284 -ne "`wc -c < 'COPYRIGHT'`"
then
	echo shar: error transmitting "'COPYRIGHT'" '(should have been 284 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'TODO'" '(894 characters)'
if test -f 'TODO'
then
	echo shar: will not over-write existing file "'TODO'"
else
sed 's/^X//' << \SHAR_EOF > 'TODO'
XWhat should be added:
X
X	* insert  mode in field  editing.  The  original  idea is that
X	  most of the fields should be short and  there  is no need to
X	  duplicate editor function in sf.  For novice user, they dont
X	  know fancy commands  anyway; for expert  user, sf is  useful
X	  only in  special  occasion.  This  delayed  the  addition of
X	  extra editing function  (insert mode, delete  word,  move by
X	  word, etc).
X
XWhat should not be added:
X
X	* Database function: I could not think of an  easy way so that
X	  sf can read  standard Unix database  files like /etc/passwd,
X	  /etc/ttys, any  idea?    It   will  be good   to have  these
X	  functions, but again, it violate Unix principle: "doing just
X	  one thing".
X
XSomething to think about:
X
X	* scroll region
X	* multiple forms, chaining to different form files.
X	* range checking.
X	* pipe field data to Unix program and put result back.
SHAR_EOF
if test 894 -ne "`wc -c < 'TODO'`"
then
	echo shar: error transmitting "'TODO'" '(should have been 894 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'Print'" '(2591 characters)'
if test -f 'Print'
then
	echo shar: will not over-write existing file "'Print'"
else
sed 's/^X//' << \SHAR_EOF > 'Print'
X#! /bin/csh -f
X#
X#-	print -  print file(s) to line printer (with sf interface)
X#-
X#	Author:		Paul Lew, General Systems Group, Salem, NH
X#	Created at:	5/8/86
X#	Last update:	01/27/88  00:03 AM  (Edition: 11)
X#
X#-	Usage:	Print filenames <CR>
X#---------------------------------------------------------------#
X#	      Display help if requested by user			#
X#---------------------------------------------------------------#
Xswitch ( "$1" )
X	case -H[xX]:
X		set echo; set verbose; shift
X		breaksw
X	case -H*:
X		show_help `which $0` $1
X		goto end
X	default:
X	endsw
X#---------------------------------------------------------------#
X#	  Display form to take input from the user		#
X#---------------------------------------------------------------#
Xset srcfile = "/tmp/form.$$"
Xsf -o ${srcfile} -u <<!
X
X	     General Systems Group Fast Printer Spooler
X
X   File Name: ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X
X	[-#] Number of copies:	~~~	      [-h] Burst Header Page: ~~~
X	[-m] Send mail on completion: ~~~     [-p] Format with pr:    ~~~
X
X	[-J] Job Name:		~~~~~~~~~~~~~
X	[-C] Class Name:	~~~~~~~~~~~~~
X	[-T] Title for pr:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X
X		    Current Print Queue Status
X`lpq | head -5`
X
X	[Press TAB to move to next field, RETURN to execute]
X
Xv=fnd=$*
Xv=copya=add=1v=bursts=/Yes/Noa=a
Xv=mails=/No/Yesa=av=prs=/Yes/Noa=a
Xv=jobd=$1
Xv=classd=`hostname`
Xv=titled=$1
X!
X#---------------------------------------------------------------#
X#	Execute script to set variables from form		#
X#---------------------------------------------------------------#
Xif ( ! -e ${srcfile} ) goto end
Xsource ${srcfile}
X#---------------------------------------------------------------#
X#	  Re-arrange variables before execution			#
X#---------------------------------------------------------------#
Xif ( "${copy}" != "1" ) then
X	set copy = "-#${copy}"
Xelse
X	set copy = ''
X	endif
X#
Xif ( "${burst}" != "Yes" ) then
X	set burst = "-h"
Xelse
X	set burst = ''
X	endif
X#
Xif ( "${pr}" == "Yes" ) then
X	set pr = "-p"
Xelse
X	set pr = ''
X	endif
X#
Xif ( "${mail}" == "Yes" ) then
X	set mail = "-m"
Xelse
X	set mail = ''
X	endif
X#
Xset tf; set cf; set jf
Xif ( "${title}" != "" ) set tf = "-T"
Xif ( "${class}" != "" ) set cf = "-C"
Xif ( "${job}" != "" ) set jf = "-J"
X#---------------------------------------------------------------#
X#		   Execute proper command ....			#
X#---------------------------------------------------------------#
Xif ( "${fn}" != "" ) then
X	lpr ${copy} ${burst} ${pr} ${mail} ${tf} "${title}" \
X	${cf} "${class}" ${jf} "${job}" ${fn}
X	endif
X/bin/rm -f ${srcfile}
Xend:
SHAR_EOF
echo shar: 26 control characters may be missing from "'Print'"
if test 2591 -ne "`wc -c < 'Print'`"
then
	echo shar: error transmitting "'Print'" '(should have been 2591 characters)'
fi
chmod +x 'Print'
fi # end of overwriting check
echo shar: extracting "'Stty'" '(10025 characters)'
if test -f 'Stty'
then
	echo shar: will not over-write existing file "'Stty'"
else
sed 's/^X//' << \SHAR_EOF > 'Stty'
X#! /bin/sh
X#
X#-	Stty - stty with form interface
X#-
X#-	This program  allows user to view  all the terminal parameters
X#-	and change them by form.  Help messages has been added to each
X#-	field to make change parameter easier.
X#
X#	Author:		Paul Lew, General Systems Group, Salem, NH
X#	Created at:	01/09/88  07:40 PM
X#	Last update:	01/12/88  10:34 PM  (Edition: 79)
X#
X#---------------------------------------------------------------#
X#     Get current tty setting and store as shell variables	#
X#---------------------------------------------------------------#
Xsttyfile="/tmp/stty$$"
Xtmpfile="/tmp/sttytmp$$"
Xtrap "trap '' 0 1 2 3 15;					\
X      /bin/rm -f $sttyfile $tmpfile;				\
X      exit" 0 1 2 3 15
Xstty everything 2> $sttyfile
Xtr -d ':()' < $sttyfile | awk \
X'BEGIN	{ q= 39; fmt = sprintf "%%s=%c%%s%c\n", q, q; }		\
X	NR == 1	{						\
X		printf fmt, "tt_tty",    $1;			\
X		printf fmt, "tt_speed",  $4;			\
X		printf fmt, "tt_row",    $6;			\
X		printf fmt, "tt_column", $8;			\
X		}						\
X	2 <= NR && NR <= 5 {					\
X		for (i=1; i<=NF; i++) {				\
X			if (substr($(i),1,1)=="-") {		\
X				yon = "No";			\
X				name = substr($(i),2,99);	\
X				}				\
X			else	{				\
X				yon = "Yes";			\
X				name = $(i);			\
X				}				\
X			print "tt_" name "=" yon;		\
X			}					\
X		}						\
X	NR == 7 {						\
X		printf fmt, "tt_erase",  $1;			\
X		printf fmt, "tt_kill",   $2;			\
X		printf fmt, "tt_werase", $3;			\
X		printf fmt, "tt_rprnt",  $4;			\
X		printf fmt, "tt_flush",  $5;			\
X		printf fmt, "tt_lnext",  $6;			\
X		n = split ($7, part, "/");			\
X		printf fmt, "tt_susp",   part[1];		\
X		printf fmt, "tt_suspo",  part[2];		\
X		printf fmt, "tt_intr",   $8;			\
X		printf fmt, "tt_quit",   $9;			\
X		n = split ($10, part, "/");			\
X		printf fmt, "tt_stop",   part[1];		\
X		printf fmt, "tt_start",  part[2];		\
X		printf fmt, "tt_eof",    $11;			\
X		}' > $tmpfile
X#---------------------------------------------------------------#
X#	     Prepare variable for sf to display			#
X#---------------------------------------------------------------#
X. $tmpfile
X/bin/rm -f $tmpfile
Xif [ $tt_raw = "Yes" ]; then tt_mode="raw"
Xelif [ $tt_cbreak = "Yes" ]; then tt_mode="cbreak"
Xelse tt_mode="cooked"
Xfi
Xif [ $tt_nl = "Yes" ]; then tt_nl="No"; else tt_nl="Yes"; fi
Xif [ $tt_litout = "Yes" ]; then tt_litout="No"; else tt_litout="Yes"; fi
Xif [ $tt_nohang = "Yes" ]; then tt_nohang="No"; else tt_nohang="Yes"; fi
X#---------------------------------------------------------------#
X#	   Invoke sf to allow user make changes			#
X#---------------------------------------------------------------#
Xs=s=/Yes/No
Xsf -o $tmpfile -bmu << sf_eof
X	  ***** Terminal Setting for BSD 4.3 System *****
X
Xtty discipline: ~~~~	speed: ~~~~~	Rows: ~~~	Columns: ~~~
X
XAccept even parity input: ~~~   Mode: ~~~~~~      Treat CR as NL: ~~~
XAccept odd  parity input: ~~~   Input Echo: ~~~   Map upper to lower: ~~~
XFlow control enable: ~~~        Print Tabs: ~~~
X
XNew TTY Discipline Specific:
X    Echo BS on erase char: ~~~    Wipe out erased char: ~~~   
X    Echo CTRL char as ^x: ~~~     Wipe out erased line: ~~~
X    Background job stop if output: ~~~   Convert tilde: ~~~  Flush output: ~~~
X    Start/Stop output on carrier transition: ~~~    Output processing: ~~~
X    Pass 8th bit: ~~~   Hang up if carrier drop: ~~~
X    Input Pending: ~~~  only XON resume output: ~~~
X
XTerminal characters:
X    char erase: ~~    reprint current line: ~~   literal next char: ~~
X    word erase: ~~    flush output: ~~
X    line erase: ~~    end of file: ~~
X    interrupt:  ~~    suspend current job: ~~    stop host output (XOFF): ~~
X    quit:       ~~    suspend with output: ~~    start host output (XON): ~~
X
X.v=tt_discipline.d=new.s=/new/net/old.
X.h=Berkeley new tty driver.
X.h=net discipline, for communication purpose.
X.h=old tty driver from V7 Unix.
X
X.v=tt_speed.d=$tt_speed.
X.s=/0/50/75/110/134/150/200/300/600/1200/1800/2400/4800/9600/exta/extb.
X.h=hang up phone line immdeidately.
X.h=50.h=75.h=110.h=134.h=150.h=200.h=300.h=600.h=1200.h=1800.h=2400.h=4800.
X.h=9600.h=exta (19200 on DH-11 board).h=extb (not implemented yet).
X
X.v=tt_row.d=$tt_row.v=tt_column.d=$tt_column.
X
X.v=tt_even.d=$tt_even.$s.
X.h=Strip parity bit for even parity input char.
X.h=Throw away even parity input char.
X
X.v=tt_mode.d=$tt_mode.s=/cooked/cbreak/raw.
X.h=Cooked mode - with input editing, end by newline.
X.h=Cbreak mode - return char as it typed except interrupt, flow control.
X.h=Raw mode - return every char as it typed.
X
X.v=tt_nl.d=$tt_nl.$s.
X.h=Allow CR for NL, and output CR-LF for CR or NL.
X.h=Accept only newline to end lines.
X
X.v=tt_odd.d=$tt_odd.$s.
X.h=Strip parity bit for odd parity input char.
X.h=Throw away odd parity input char.
X
X.v=tt_echo.d=$tt_echo.$s.
X.h=Echo back every character typed.
X.h=Do not echo characters, good for Emacs inferior shell.
X
X.v=tt_lcase.d=$tt_lcase.$s.
X.h=This is for terminal that do not have lowercase letter.
X.h=This is for modern day terminal.
X
X.v=tt_tandem.d=$tt_tandem.$s.
X.h=system sends out stop/start char when queue is near overflow/empty.
X.h=Application program have to handle XON/OFF.
X
X.v=tt_tabs.d=$tt_tabs.$s.
X.h=Preserve tabs when printing.
X.h=Replace tabs by spaces when printing (for terminal with no hardware tabs).
X
X.v=tt_crtbs.d=$tt_crtbs.$s.
X.h=Echo backspaces on erase characters, useful for CRT.
X.h=do not echo backspaces on erase characters, useful for hardcopy terminals.
X
X.v=tt_crterase.d=$tt_crterase.$s.
X.h=Wipe out erased characters with backspace-space-backspace.
X.h=Echo erased characters backwards within \\ and /.
X
X.v=tt_ctlecho.d=$tt_ctlecho.$s.
X.h=Delete will be ^?, print two BS following the EOT char (CTRL D).
X.h=CTRL char echo as themselves; in cooked mode EOT (CTRL-D) is not echoed.
X
X.v=tt_crtkill.d=$tt_crtkill.$s.
X.h=Wipe out input on like kill ala crterase.
X.h=Just echo line kill character and a newline on line kill.
X
X.v=tt_tostop.d=$tt_tostop.$s.
X.h=Background jobs stop if they attempt terminal output.
X.h=Output from background jobs to the terminal is allowed.
X
X.v=tt_tilde.d=$tt_tilde.$s.
X.h=Convert ~ to \` on output (for Hazeltine terminals).
X.h=Leave poor ~ char alone.
X
X.v=tt_flusho.d=$tt_flusho.$s.
X.h=Output is being discarded usually because user hit CTRL O.
X.h=Output is not being discarded.
X
X.v=tt_mdmbuf.d=$tt_mdmbuf.$s.
X.h=Start/stop output on carrier transitions.
X.h=Return error if write attempted after carrier drops.
X
X.v=tt_litout.d=$tt_litout.$s.
X.h=Do normal output processing, inserting delays, etc.
X.h=Send output characters without any processing.
X
X.v=tt_pass8.d=$tt_pass8.$s.
X.h=pass 8th bit.
X.h=strip off 8th bit.
X
X.v=tt_nohang.d=$tt_nohang.$s.
X.h=Send hangup signal to control process group when carrier drops.
X.h=Do not send hangup signal if carrier drops.
X
X.v=tt_pendin.d=$tt_pendin.$s.
X.h=Input is pending after a switch from cbreak to cooked.
X.h=Input is not pending.
X
X.v=tt_decctlq.d=$tt_decctlq.$s.
X.h=This is compatible with DEC vendor supplied systems.
X.h=After output is suspended, any char will restart it.
X
X.v=tt_erase.d=$tt_erase.v=tt_rprnt.d=$tt_rprnt.v=tt_lnext.d=$tt_lnext.
X.v=tt_werase.d=$tt_werase.v=tt_flush.d=$tt_flush.
X.v=tt_kill.d=$tt_kill.v=tt_eof.d=$tt_eof.
X.v=tt_intr.d=$tt_intr.v=tt_susp.d=$tt_susp.v=tt_stop.d=$tt_stop.
X.v=tt_quit.d=$tt_quit.v=tt_suspo.d=$tt_suspo.v=tt_start.d=$tt_start.
Xsf_eof
X#---------------------------------------------------------------#
X#		  Process variable returned			#
X#---------------------------------------------------------------#
X. $tmpfile
X/bin/rm -f $tmpfile $sttyfile
Xtt_even=`[ $tt_even = "Yes" ] || echo -`even
Xcase $tt_mode in
X	cooked)	tt_raw='-raw'; tt_cbreak='-cbreak';;
X	cbreak)	tt_raw='-raw'; tt_cbreak='cbreak';;
X	raw)	tt_raw='raw';  tt_cbreak='-cbreak';;
X	esac
Xtt_nl=`[ $tt_nl = "No" ] || echo -`nl
Xtt_odd=`[ $tt_odd = "Yes" ] || echo -`odd
Xtt_echo=`[ $tt_echo = "Yes" ] || echo -`echo
Xtt_lcase=`[ $tt_lcase = "Yes" ] || echo -`lcase
Xtt_tandem=`[ $tt_tandem = "Yes" ] || echo -`tandem
Xtt_tabs=`[ $tt_tabs = "Yes" ] || echo -`tabs
Xtt_crtbs=`[ $tt_crtbs = "Yes" ] || echo -`crtbs
Xtt_crterase=`[ $tt_crterase = "Yes" ] || echo -`crterase
Xtt_ctlecho=`[ $tt_ctlecho = "Yes" ] || echo -`ctlecho
Xtt_crtkill=`[ $tt_crtkill = "Yes" ] || echo -`crtkill
Xtt_tostop=`[ $tt_tostop = "Yes" ] || echo -`tostop
Xtt_tilde=`[ $tt_tilde = "Yes" ] || echo -`tilde
Xtt_flusho=`[ $tt_flusho = "Yes" ] || echo -`flusho
Xtt_mdmbuf=`[ $tt_mdmbuf = "Yes" ] || echo -`mdmbuf
Xtt_litout=`[ $tt_litout = "No" ] || echo -`litout
Xtt_pass8=`[ $tt_pass8 = "Yes" ] || echo -`pass8
Xtt_nohang=`[ $tt_nohang = "No" ] || echo -`nohang
Xtt_pendin=`[ $tt_pendin = "Yes" ] || echo -`pendin
Xtt_decctlq=`[ $tt_decctlq = "Yes" ] || echo -`decctlq
Xtt_noflsh=`[ $tt_noflsh = "Yes" ] || echo -`noflsh
X#---------------------------------------------------------------#
X#	Output stty command to file (or stdout if no arg)	#
X#---------------------------------------------------------------#
Xif [ "$1" = "" ]; then
X	sttyfile=/dev/tty
Xelse
X	sttyfile="$1"
X	fi
Xcat > $sttyfile << cat_eof
Xset noglob
Xstty $tt_discipline  speed $tt_speed				\\
X    $tt_even $tt_odd $tt_raw $tt_nl $tt_echo $tt_lcase		\\
X    $tt_tandem	$tt_tabs $tt_cbreak				\\
X    $tt_crtbs $tt_crterase $tt_crtkill $tt_ctlecho $tt_tostop	\\
X    $tt_tilde $tt_flusho $tt_mdmbuf $tt_litout $tt_pass8	\\
X    $tt_nohang $tt_pendin $tt_decctlq $tt_noflsh		\\
X    erase "$tt_erase"  rprnt "$tt_rprnt"  lnext "$tt_lnext"	\\
X    werase "$tt_werase"  flush "$tt_flush"			\\
X    kill "$tt_kill"  eof "$tt_eof"				\\
X    intr "$tt_intr"  susp "$tt_suspd"  stop "$tt_stop"		\\
X    quit "$tt_quit"  susp "$tt_suspd"  start "$tt_start"
Xunset noglob
Xcat_eof
X#
X# 1) new tty, speed 1200 baud, 24 rows, 80 columns
X# 2) even odd -raw -nl echo -lcase -tandem tabs -cbreak 
X# 3) crt: (crtbs crterase crtkill ctlecho) -tostop 
X# 4) -tilde -flusho -mdmbuf -litout -pass8 -nohang 
X# 5) -pendin decctlq -noflsh 
X# 6) erase  kill   werase rprnt  flush  lnext  susp   intr   quit   stop   eof
X# 7)  ^?    ^U     ^W     ^R     ^O     ^V     ^Z/^Y  ^C     ^\     ^S/^Q  ^D
X#      1     2      3      4      5      6      7      8      9      10    11
SHAR_EOF
if test 10025 -ne "`wc -c < 'Stty'`"
then
	echo shar: error transmitting "'Stty'" '(should have been 10025 characters)'
fi
chmod +x 'Stty'
fi # end of overwriting check
echo shar: extracting "'Lib'" '(8749 characters)'
if test -f 'Lib'
then
	echo shar: will not over-write existing file "'Lib'"
else
sed 's/^X//' << \SHAR_EOF > 'Lib'
X#! /bin/csh -f
X#
X#-	gsglib - GSG library on-line query
X#-
X#	Author:		Paul Lew, General Systems Group, Inc.
X#	Created at:	08/15/86  04:18 PM
X#	Last update:	01/26/88  12:31 PM  (Edition: 8)
X#
X#-	Usage:		gsglib <CR>
X#
X#---------------------------------------------------------------#
X#	      Display help if requested by user			#
X#---------------------------------------------------------------#
Xswitch ( "$1" )
X	case -H[xX]:
X		set echo; set verbose; shift
X		breaksw
X	case -H*:
X		show_help `which $0` $1
X		goto end
X	default:
X	endsw
X#---------------------------------------------------------------#
X#			Process Arguments			#
X#---------------------------------------------------------------#
Xset libfile = '/gsg/lew/dat/gsglib.dat'
Xset tmpfile = "/tmp/gsglib.$$"
Xunsetenv LESS
X#---------------------------------------------------------------#
X#	Display main menu and get user input (use sf)		#
X#---------------------------------------------------------------#
Xloop:
Xset srcfile = "/tmp/gsglib$$"
Xsf -o ${srcfile} -u << sf_eof
X	General Systems Group Library Directory
X
X     Operation: ~~~~~~~	[choice: find add new print keyword help quit]
X
X
X     Book number:   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X     ~~~  Keyword:	  ~~~~~~~~~~~~~~~
X     ~~~  Author:	  ~~~~~~~~~~~~~~~~~~~~~~~~
X     ~~~  Title:	  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X     ~~~  Date published: ~~~~~~~~~~~~~
X     ~~~  Publisher:	  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X     ~~~  Book id:	  ~~~~~~~~~~~~~~~~~~~~~~~
X     ~~~  Number of pages:~~~~~
X
X     ^
X     +------ enter "y" to include in the output list
X
X	[Press TAB to move to next field, RETURN to execute]
X
X.v=opcode.s=/find/add/new/print/keyword/help/quit.
X.h=find out what books has the data we want.
X.h=add new books to library.
X.h=see what are the new books since last use.
X.h=print out previous output to printer.
X.h=display all the predefined keywords that are valid for keyword search field.
X.h=display help message about how to use this program.
X.h=quit, exit back to Unix.
X.v=bookno.
X.v=selkw.s=/No/Yes.v=keyword.
X.v=selau.s=/Yes/No.v=author.
X.v=selti.s=/Yes/No.v=title.
X.v=selpd.s=/Yes/No.v=pdate.
X.v=selpu.s=/Yes/No.v=pub.
X.v=selbi.s=/No/Yes.v=bookid.
X.v=selsz.s=/No/Yes.v=size.
Xsf_eof
X#---------------------------------------------------------------#
X#	Get symbol defined for the current process		#
X#---------------------------------------------------------------#
Xif ( ! -e ${srcfile} ) goto end
Xsource ${srcfile}
X/bin/rm -f ${srcfile}
X#---------------------------------------------------------------#
X#		    Execute user request			#
X#---------------------------------------------------------------#
X#echo "author=[${author}] output select=[${selau}]"
X#echo "keyword=[${keyword}] output select=[${selkw}]"
X#echo "title=[${title}] output select=[${selti}]"
X#echo "pdate=[${pdate}] output select=[${selpd}]"
X#echo "pub=[${pub}] output select=[${selpu}]"
X#echo "press return: "
X#set yon = "$<"
Xif ( "${bookno}" == "vi" ) then
X	goto libvi
X	endif
Xswitch ( "${opcode}" )
X	case "find":
X		goto libfind
X	case "add":
X		goto libadd
X	case "new":
X		goto libnew
X	case "print":
X		goto libprint
X	case "keyword":
X		goto libkeyword
X	case "help":
X		goto libhelp
X	case "quit":
X		goto end
X	default:
X		echo "Unknown command: ${opcode}"
X		sleep 2
X		goto loop
X		breaksw
X	endsw
X#---------------------------------------------------------------#
X#		add a new record to library file		#
X#---------------------------------------------------------------#
Xlibfind:
X	cat /dev/null > ${tmpfile}
X	set outsel
X	if ( "${selkw}" == "Yes" ) set outsel = "${outsel}K"
X	if ( "${selau}" == "Yes" ) set outsel = "${outsel}A"
X	if ( "${selti}" == "Yes" ) set outsel = "${outsel}T"
X	if ( "${selpd}" == "Yes" ) set outsel = "${outsel}D"
X	if ( "${selpu}" == "Yes" ) set outsel = "${outsel}P"
X	if ( "${selbi}" == "Yes" ) set outsel = "${outsel}N"
X	if ( "${selsz}" == "Yes" ) set outsel = "${outsel}S"
X	if ( "${outsel}" == "" ) then
X		echo -n "No output selection"
X		goto getret
X		endif
X	if ( "${bookno}" != "" ) then
X		set recno = (${bookno})
X		goto grepno
X		endif
X	if ( "${keyword}" != "" ) then
X		grep '^#K' ${libfile} | grep -i "${keyword}" >> ${tmpfile}
X		endif
X	if ( "${author}" != "" ) then
X		grep '^#A' ${libfile} | grep -i "${author}" >> ${tmpfile}
X		endif
X	if ( "${title}" != "" ) then
X		grep '^#T' ${libfile} | grep -i "${title}" >> ${tmpfile}
X		endif
X	if ( "${pdate}" != "" ) then
X		grep '^#D' ${libfile} | grep -i "${pdate}" >> ${tmpfile}
X		endif
X	if ( "${pub}" != "" ) then
X		grep '^#P' ${libfile} | grep -i "${pub}" >> ${tmpfile}
X		endif
X	if ( "${bookid}" != "" ) then
X		grep '^#N' ${libfile} | grep -i "${bookid}" >> ${tmpfile}
X		endif
X	if ( "${size}" != "" ) then
X		grep '^#S' ${libfile} | grep -i "${size}" >> ${tmpfile}
X		endif
X	if ( -z ${tmpfile} ) then
X		echo -n "No related information"
X		goto getret
X	else
X		set recno = `awk '{ print $2 }' ${tmpfile} | sort -u`
X		cat /dev/null > ${tmpfile}
Xgrepno:
X		foreach rec (${recno})
X			bm "${rec}" ${libfile} | awk 'NF>2' | \
X			grep "^#[${outsel}]" >> ${tmpfile}
X			echo "---------------------------" >> ${tmpfile}
X			end
X		less -pcu ${tmpfile}
X		endif
X	goto loop
X#---------------------------------------------------------------#
X#		add a new record to library file		#
X#---------------------------------------------------------------#
Xlibadd:
X	if ( "${user}" != "secrtary" && "${user}" != "chicca" && ${user} != "lew" ) then
Xerr:
X		echo -n '...Sorry, only secretary can update library info'
X		goto getret
X		breaksw
X		endif
X	if ( "${title}" == "" ) then
X		echo "...You can not add a record without title..."
X		sleep 1
X		goto loop
X		endif
X	@ rec = `tail -1 ${libfile} | awk '{print $2}'`
X	@ rec ++
X	set recno = "${rec}"
X	if ( $rec < 1000 ) set recno = "0${recno}"
X	if ( $rec < 100 ) set recno = "0${recno}"
X	if ( $rec < 10 ) set recno = "0${recno}"
X	cat >> ${libfile} << cat_eof
X
X#K ${recno}	${keyword}
X#A ${recno}	${author}
X#P ${recno}	${pub}
X#T ${recno}	${title}
X#N ${recno}	${bookid}
X#D ${recno}	${pdate}
X#S ${recno}	${size}
X#R ${recno}	`date`
Xcat_eof
X	echo "Record ${recno} has been added successfully"
X	sleep 1
X	goto loop
X#---------------------------------------------------------------#
X#	    show all new books since last check			#
X#---------------------------------------------------------------#
Xlibnew:
X	if ( ! -e ~/.gsgbook ) then
X		@ old = 0
X	else
X		@ old = `cat ~/.gsgbook`
X		endif
X	grep '^#T' ${libfile} | awk		\
X	'BEGIN			{ p = 0 }	\
X	 p == 1			{ print }	\
X	 $2 ~ /'"${old}"'/	{ p = 1 }' | less -pcu
X	tail -1 ${libfile} | awk '{ print $2 }' > ~/.gsgbook
X	goto loop
X#---------------------------------------------------------------#
X#	   display all possible keyword defined			#
X#---------------------------------------------------------------#
Xlibkeyword:
X	(echo "...Possible Keywords List in Library...";	\
X	 grep '^#K' ${libfile} | awk				\
X	 '{ for (i=3; i<=NF; i++) {				\
X		print $i;					\
X		}						\
X	  }') | sort -u | awk					\
X	'NR == 1 { print }					\
X	 NR > 1	{						\
X		printf "%-18s", $0;				\
X		if (++i % 4 == 0) printf "\n";			\
X		}						\
X	 END	{ if (i % 4 != 0) printf "\n"; }' | less -pcu
X	goto loop
X#---------------------------------------------------------------#
X#	    print previous located collection of data		#
X#---------------------------------------------------------------#
Xlibprint:
X	if ( -e ${tmpfile} && ! -z ${tmpfile} ) then
X		print ${tmpfile}
X	else
X		echo -n "Nothing to print"
Xgetret:
X		echo -n ", press RETURN to continue: "
X		set yon = "$<"
X		endif
X	goto loop
X#---------------------------------------------------------------#
X#      run vi on the library file (undocumented feature)	#
X#---------------------------------------------------------------#
Xlibvi:
X	vi ${libfile}
X	goto loop
X#---------------------------------------------------------------#
X#	   display usage guide for inexperience users		#
X#---------------------------------------------------------------#
Xlibhelp:
X	cat << cat_eof
Xadd	add a new record into library database, privilege required
Xnew	display what new books has arrived since last use
Xfind	search for proper information
Xhelp	display this usage guide
Xkeyword	show all current available keywords
Xprint	print the result from the last find command
Xquit	exit
X
XYou may enter search string in any of the fields (grep -i will be used
Xin each occassion). If you specify book numbers, all the other fields
Xwill be ignored.
X
XThe one character fields at the beginning of each field is output
Xselect, if it is 'y', it will be included in the output.
X
Xcat_eof
X	echo -n "End of help info"
X	goto getret
X#---------------------------------------------------------------#
X#		Clean up and exit here...			#
X#---------------------------------------------------------------#
Xend:
X	/bin/rm -f ${tmpfile}
X	unset fnames fname srcfile tmpfile
SHAR_EOF
if test 8749 -ne "`wc -c < 'Lib'`"
then
	echo shar: error transmitting "'Lib'" '(should have been 8749 characters)'
fi
chmod +x 'Lib'
fi # end of overwriting check
echo shar: extracting "'basic.h'" '(829 characters)'
if test -f 'basic.h'
then
	echo shar: will not over-write existing file "'basic.h'"
else
sed 's/^X//' << \SHAR_EOF > 'basic.h'
X#if	!defined (YES)
X#define	YES	1
X#endif
X
X#if	!defined (NO)
X#define	NO	0
X#endif
X
X#if	!defined (EOS)
X#define	EOS	'\0'
X#endif
X
X#if	!defined (TAB)
X#define	TAB	'\t'
X#endif
X
X#if	!defined (NULL)
X#define	NULL	0
X#endif
X
X#if	defined (CTRL)
X#undef	CTRL
X#endif
X#define	CTRL(x)	((x) & 0xbf)
X
X#define	LOW_GCHAR	' '
X#define	HIGH_GCHAR	'~'
X
X#ifdef	DEBUG
X#define	ENTER(name)	static char *rname = "name";			\
X			{						\
X			Level++;					\
X			fprintf (stderr, "%*s%s\n", -(Level*4), "-",	\
X				 rname);				\
X			fflush (stderr);				\
X			}
X#define	RETURN(x)	{Level--; return (x);}
X#define	EXIT		{Level--; return; }
X#else
X#define	ENTER(name)
X#define	RETURN		return
X#define	EXIT		return
X#endif
X
X#define	when		break;case
X#define	otherwise	break;default
X
X#ifndef	EXTERN
X#define	EXTERN	extern
X#endif
X
XEXTERN	int	Level;		/* level of function call debug */
SHAR_EOF
if test 829 -ne "`wc -c < 'basic.h'`"
then
	echo shar: error transmitting "'basic.h'" '(should have been 829 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'form.h'" '(1383 characters)'
if test -f 'form.h'
then
	echo shar: will not over-write existing file "'form.h'"
else
sed 's/^X//' << \SHAR_EOF > 'form.h'
X/* Screen controls */
X 
X#define SCR_ERASE	0	/* clear screen			*/
X#define SCR_HOME	1	/* home the cursor		*/
X#define SCR_EEOL	2	/* erase to end of line		*/
X#define SCR_DEL		3	/* BS SPACE BS			*/
X#define SCR_SAVE	4	/* save cursor position		*/
X#define SCR_RESTORE	5	/* restore cursor position	*/
X#define SCR_REVERSE	6	/* reverse video mode		*/
X#define SCR_NORMAL	7	/* normal video mode		*/
X#define SCR_BACKSPACE	8	/* cursor left			*/
X#define SCR_KEYXMIT	9	/* enter keypad xmit mode	*/
X#define SCR_NOKEYXMIT	10	/* exit keypad xmit mode	*/
X 
X#define EF_OK	1		/* field is ok */
X#define EF_ERR	2		/* error on field */
X#define EF_BOF	3		/* start by placing cursor at beg of field */
X#define EF_EOF	4		/* start by placing cursor at end of field */
X#define EF_FILL 5		/* fill rest of field */
X 
X/* update field options */
X 
X#define UF_MONEY	1	/* money format: dollar.cents */
X#define UF_NUMBER	2	/* number */
X#define UF_STRING	3	/* string to display */
X#define UF_TIME		4	/* current time - HH:MM */
X#define UF_DATE		5	/* today's date - MM/DD/YY */
X
X#define SCRLINE		24	/* number of lines on screen */
X#define SCRCOL		80	/* number of columns on screen */
X#define MAXVNAME	500	/* # of chars in variable name pool */
X#define MAXFNAME	80	/* # of chars allowed in filename */
X 
X#define	BOURNE		1	/* bourne shell output */
X#define	CSH		2	/* C shell output */
X#define	PERL		3	/* perl script output */
SHAR_EOF
if test 1383 -ne "`wc -c < 'form.h'`"
then
	echo shar: error transmitting "'form.h'" '(should have been 1383 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'field.h'" '(665 characters)'
if test -f 'field.h'
then
	echo shar: will not over-write existing file "'field.h'"
else
sed 's/^X//' << \SHAR_EOF > 'field.h'
X#define MAXFIELD	200
X
Xstruct	field	{
X	unsigned char	f_line;		/* line number (1-24) */
X	unsigned char	f_col;		/* column number (1-80) */
X	unsigned char	f_off;		/* offset from beg of line */
X	unsigned char	f_len;		/* field size (bytes) */
X	unsigned	f_attr;		/* attributes */
X#define	FA_AUTOTAB	0x01		/* move to next field at eof */
X#define	FA_SELECTION	0x02		/* selection field */
X#define	FA_BLOCK	0x04		/* block type */
X#define	FA_NUMERIC	0x08		/* nuermic only field */
X	char		**f_sel;	/* ptr to selection array */
X	char		**f_help;	/* ptr to help message array */
X	unsigned char	f_sno;		/* current selection index */
X	char		*f_var;		/* variable to set at end */
X	};
SHAR_EOF
if test 665 -ne "`wc -c < 'field.h'`"
then
	echo shar: error transmitting "'field.h'" '(should have been 665 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'term.h'" '(285 characters)'
if test -f 'term.h'
then
	echo shar: will not over-write existing file "'term.h'"
else
sed 's/^X//' << \SHAR_EOF > 'term.h'
X#define	BC	0
X#define	CM	1
X#define	CL	2
X#define	CD	3
X#define	CE	4
X#define	HO	5
X#define	KS	6
X#define	KE	7
X#define	KU	8
X#define	KD	9
X#define	KL	10
X#define	KR	11
X#define	MD	12
X#define	ME	13
X#define	RC	14
X#define	SC	15
X#define	SO	16
X#define	SE	17
X#define	US	18
X#define	UE	19
X#define	BAD	20
SHAR_EOF
if test 285 -ne "`wc -c < 'term.h'`"
then
	echo shar: error transmitting "'term.h'" '(should have been 285 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'Makefile'" '(3543 characters)'
if test -f 'Makefile'
then
	echo shar: will not over-write existing file "'Makefile'"
else
sed 's/^X//' << \SHAR_EOF > 'Makefile'
X###############################################################################
X#
X#	Copyright (C)   Paul Lew, 1988, All rights reserved
X#
X#	sccsid = "%W% %G%"
X#
X#	File Name:	Makefile
X#
X#	Author:         Paul Lew
X#	Creation Date:  05/07/86  05:06 PM
X#	Last update:	02/07/88  10:29 PM  (Edition: 25)
X#
X#	Function:	Makefile for shell form editor
X#
X#	Update History:
X#	     Date		Modification Description		By
X#	   --------	-----------------------------------------------	---
X#	   05/07/86	Initial version					Lew
X#	   08/01/87	Added field.h, split shform.c into load.c,	Lew
X#			option.c, field.c, and form.c			Lew
X#	   01/11/88	Added field.h (was missing)			Lew
X#	   01/13/88	Added summary.c					Lew
X#	   01/14/88	Added make zoo					Lew
X#	   01/28/88	Added make shar					Lew
X#	   02/07/88	Added Makefile to shar list (was missing)	Lew
X#	   02/07/88	Added COPYRIGHT					Lew
X#
X###############################################################################
XTITLE = sf
X
XMODULE	= sf
XOBJECTS	= sf.o form.o load.o field.o selection.o keyword.o	\
X	  option.o msg.o term.o io.o summary.o
XFILES	= sf.c form.c load.c field.c selection.c keyword.c	\
X	  option.c msg.c term.c io.c summary.c
XEXAMPLES= Print Stty Lib
XINFO	= sf.1 README MANIFEST COPYRIGHT TODO
XLIBS	= /gsg/lew/c/getopt.o
XLIBSRC	=
XCFLAGS	= -n -gx
XLIBRARY	= -ltermcap
XINCLUDES= basic.h form.h field.h term.h
XEDITION	= 1
X#------------ The remainder of this makefile is module independent -------#
X
X.SUFFIXES: .rel .obj .r .o .c
X
XCFLAG2	=
XCREF	= /gsg/lew/bin/cref
XDEPEND	= /gsg/lew/sh/depend
X
X#------------- Make executable -------------------------------------------#
X
X$(MODULE):	$(OBJECTS) $(LIBS)
X		$(CC) $(CFLAGS) -o $(MODULE) $(OBJECTS) $(LIBS) $(LIBRARY)
X
X.c.o:
X		$(CC) $(CFLAGS) $(CFLAG2) -c $*.c
X
X#------------- Utilities -------------------------------------------------#
X
Xutil:		lint TAGS listing depend
X
Xlint:		$(FILES)
X		lint $(FILES) > lint
X
XTAGS:		$(INCLUDES) $(FILES)
X		etags $(INCLUDES) $(FILES)
X
Xlisting:	$(INCLUDES) $(FILES)
X		-$(CREF) $(INCLUDES) $(FILES) > listing
X
Xprint:		listing xxx
Xxxx:
X		lpr -J '$(TITLE)' listing
X
Xdepend:		$(FILES)
X		@ touch depend
X		@ $(DEPEND) $(FILES)
X
Xname:
X		@ echo $(INCLUDES) $(FILES)
X
Xzoo:
X		@ /bin/rm -f sf.zoo
X		zoo a sf RCS/* TAGS ID
X		@ chmod a-w sf.zoo; ls -l sf.zoo
X
Xshar:
X		echo '----shar.01-----' > MANIFEST
X		vitals $(INFO) $(EXAMPLES) $(INCLUDES) Makefile >> MANIFEST
X		echo '----shar.02-----' >> MANIFEST
X		vitals $(FILES) >> MANIFEST
X		shar -a $(INFO) $(EXAMPLES) $(INCLUDES) Makefile > shar.01
X		shar -a $(FILES) > shar.02
X
Xhelp:
X		@ echo "make lint     -- generate lint file: lint"
X		@ echo "make TAGS     -- generate tag file:  TAGS"
X		@ echo "make listing  -- generate cross ref listing:  listing"
X		@ echo "make print    -- print out listing:  listing"
X		@ echo "make depend   -- update makefile dependency rule"
X		@ echo "make util     -- do all above"
X		@ echo "make name     -- output source name list"
X		@ echo "make zoo      -- recreate sf.zoo archive"
X		@ echo "make shar     -- create shell archive files"
X#-------------------------------------------------------------------------#
X# DO NOT DELETE THIS LINE, auto-generated dependency rules follow:
Xfield.o:		basic.h field.h form.h term.h
Xform.o:		basic.h field.h form.h term.h
Xkeyword.o:	basic.h
Xload.o:		basic.h field.h form.h
Xmsg.o:		basic.h form.h
Xoption.o:	basic.h form.h
Xselection.o:	basic.h field.h form.h term.h
Xsf.o:		basic.h form.h
Xsummary.o:	basic.h form.h
Xterm.o:		form.h term.h
X#
X# Rules made at:		Thu Jan 28 20:55:24 EST 1988  by lew
X# DEPENDENCIES END HERE.
SHAR_EOF
if test 3543 -ne "`wc -c < 'Makefile'`"
then
	echo shar: error transmitting "'Makefile'" '(should have been 3543 characters)'
fi
fi # end of overwriting check
#	End of shell archive
exit 0

-- 
Please send comp.sources.unix-related mail to rsalz@uunet.uu.net.


